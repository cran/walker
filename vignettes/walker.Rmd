---
title: "Efficient Bayesian linear regression with time-varying coefficients"
author: "Jouni Helske"
date: "8 June 2017"
output:
html_document: default
bibliography: walker.bib
link-citations: true
vignette: |
  %\VignetteIndexEntry{Efficient Bayesian linear regression with time-varying coefficients}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  %\VignetteDepends{rstan}
---
  
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(walker)
```

## Introduction

Dynamic linear regression models are extension to basic linear regression models where instead of constant but unknown regression coefficients, the underlying coefficients are assumed to vary over "time" according to random walk. These types of models allow robust modelling of phenomenas where the effect size of the predictor variables and the response variable can vary during the period of the study. The `R` [@R] package `walker` provides an efficient method for fully Bayesian inference of such models, where the main computations are performed using state-of-the-art Markov chain Monte Carlo (MCMC) algorithms provided by `Stan` [@stan, @rstan]. This also allows the straightforward use of many diagnostic and graphical tools provided by several `Stan` related `R` packages such as `ShinyStan` [@shinystan].

More specifically, the dynamic regression model is defined as
$$
\begin{aligned}
y_t &= x'_t \beta_t + \epsilon_t, \quad t = 1,\ldots, n\\
\beta_{t+1} &= \beta_t + \eta_t,
\end{aligned}
$$
where $y_t$ is the observation at time $t$, $x_t$ contains the corresponding predictor variables, $\beta_t$ is a $k$ dimensional vector of regression coefficients at time $t$, $\epsilon_t \sim N(0, \sigma^2_{\epsilon})$, and $\eta_t \sim N(0, D)$, with $D$ being $k \times k$ diagonal matrix with diagonal elements $\sigma^2_{i,\eta}$, $i=1,\ldots,k$. Denote the unknown parameters of the model by $\beta = (\beta_1, \ldots, \beta_n)$ and $\sigma = (\sigma_{\epsilon}, \sigma_{1, \eta}, \ldots, \sigma_{k, \eta})$. We define priors for first $\beta_1$ as $N(\mu_{\beta_1}, \sigma_{\beta_1})$, and for $\sigma_i \sim N(\mu_{\sigma_i}, \sigma_{\sigma_i})$, $i=1,\ldots,k+1$, truncated to positive values, with slighly awful notation.

Although in principle writing dynamic regression model above in `Stan` language is straighforward, most intuitive implementations are computationally inefficient and prone to severe problems related to convergence of the underlying MCMC algorithm. The approach used by `walker` is based on the marginalization of the regression coefficients $\beta$ during the MCMC sampling by using the Kalman filter, and which provides fast and accurate inference of marginal posterior $p(\sigma | y)$, and the corresponding joint posterior $p(\sigma, \beta | y) = p(\beta | \sigma, y)p(\sigma | y)$ can then be obtained by simulating the regression coefficients given sampled standard deviations using the Kalman smoothing based simulation algorithms such as [@durbin-koopman2002]. Note that we have opted to sample the $\beta$ parameters given $\sigma$'s, but it is also possible to obtain somewhat more accurate summary statistics such as mean and variance of these parameters by using the standard Kalman smoother for compution of $\textrm{E}(\beta| \sigma, y)$ and $\textrm{Var}(\beta| \sigma, y)$, and using the law of total expectation.

## Illustration

Let us consider a observations $y$ of length $n=100$, generated by random walk (i.e. time varying intercept) and two predictors. This is rather small problem, but it was chosen in order to make possible comparisons with the "naive" implementation. For larger problems (in terms of number of observations and especially number of predictors) it is very difficult to get naive implementation to work at all, as even after tweaking several parameters of the underlying MCMC sampler, one typically ends up with divergent transitions or low BMFI index, meaning that the results are not to be trusted. 

First we simulate the coefficients and the predictors:

```{r example}
set.seed(1)
n <- 100
beta1 <- cumsum(c(0.5, rnorm(n - 1, 0, sd = 0.05)))
beta2 <- cumsum(c(-1, rnorm(n - 1, 0, sd = 0.15)))
x1 <- n:1 / 10
x2 <- cos(1:n)
u <- cumsum(rnorm(n, 0, 0.5))
ts.plot(cbind(u, beta1 * x1, beta2 * x2), col = 1:3)
```

```{r observations}
signal <- u + beta1 * x1 + beta2 * x2
y <- rnorm(n, signal, 0.5)
ts.plot(signal)
lines(y, col = 2)
```

Then we can call function `walker`. The model is defined as a formula like in `lm`, and we can give several arguments which are passed to `sampling` method of `rstan`, such as number of iteration `iter` and number of chains `chains` (default values for these are 2000 and 4). In addition to these, we use arguments `beta_prior` and `sigma_prior`, which define the prior distributions for $\beta$ and $\sigma$ respectively. These arguments should be two-column matrices, where the first column defines the prior means, and the second column defines the prior standard deviations.

```{r walker}
kalman_walker <- walker(y ~ x1 + x2, refresh = 0, chains = 2,
  beta_prior = cbind(0, rep(5, 3)), sigma_prior = cbind(0, rep(2, 4)))
print(kalman_walker, pars = c("sigma_y", "sigma_b"))
library("rstan")
stan_plot(kalman_walker, pars = c("sigma_y", "sigma_b"))
```

We often get few (typically one) warning message about numerical problems, as the sampling algorithm warms up, but this is nothing to be concerned with (if more errors occur, then a Github issue for `walker` package is more than welcome). 

Using the `extract` method of `rstan` we can pick up the samples corresponding to $\beta$'s, and we can for example plot the posterior mean paths with `ts.plot` (the dashed lines correspond to true values):

```{r plot_betas}
betas <- summary(kalman_walker, "beta")$summary

ts.plot(cbind(u, beta1, beta2, 
  matrix(betas[, c("mean", "2.5%", "97.5%")], ncol = 9)),
  col = c(1:3, rep(1:3, 3)), lty = rep(1:2, times = c(3, 9)))
```

We can perform the same analysis with naive implementation by setting the argument `naive` to `TRUE`:

```{r naive}
naive_walker <- walker(y ~ x1 + x2, seed = 1, refresh = 0, chains = 2,
  beta_prior = cbind(0, rep(5, 3)), sigma_prior = cbind(0, rep(2, 4)),
  naive = TRUE, control = list(adapt_delta = 0.9, max_treedepth = 15))
print(naive_walker, pars = c("sigma_y", "sigma_b"))

sum(get_elapsed_time(kalman_walker))
sum(get_elapsed_time(naive_walker))
```

With naive implementation we get smaller effective sample sizes and much higher computation time, as well as some indications of divergence problems, even with adjusted step size (argument `adapt_delta`).

## Posterior predictive checks and out-of-sample predictions

The `walker` function also returns samples from the posterior predictive distribution $p(y^{\textrm{rep}} | y) = \int p(y^{\textrm{rep}} | \beta, \sigma, y) p(\beta, \sigma | y) \textrm{d}\beta\textrm{d}\sigma$. This can be used to used for example in assessment of model "fit" to the data. By comparing the replication series (mean and 95% quantiles in black) and the original observations (in red) we see that very good overlap, which is not that suprising given that we know the correct model:

```{r ppc}
y_rep <- summary(kalman_walker, "y_rep")$summary
ts.plot(y_rep[, c("mean", "2.5%", "97.5%")], lty = c(1, 2, 2))
lines(y, col = 2)
```

It is also possible to perform actual predictions given new covariates $x^{new}$ (Currently we need to run whole MCMC procedure for this but a separate function which uses the output of `walker` will likely be added in future).

```{r prediction}
original_data <- data.frame(y = head(y, 95), x1 = head(x1, 95), x2 = head(x2, 95))
new_data <- data.frame(x1 = tail(x1, 5), x2 = tail(x2, 5))
walker_predict <- walker(y ~ x1 + x2, data = original_data, newdata = new_data, 
  iter = 2000, chains = 1, seed = 1, refresh = 0,
  beta_prior = cbind(0, rep(2, 3)), sigma_prior = cbind(0, rep(2, 4)))
intervals <- summary(walker_predict, pars = "y_new")$summary[, c("mean", "2.5%", "97.5%")]
ts.plot(ts(y), ts(intervals, start = 96),
  col = c(1, 2, 2, 2), lty = c(1, 1, 2, 2))
```

## Discussion

In this vignette we illustrated the benefits of marginalisation in the context of dynamic regression models. The underlying idea is not new; this approach is typical especially in classic Metropolis-type algorithms for linear-Gaussian state space models where the marginal likelihood $p(y | \theta)$ (where $\theta$ denotes the hyperparameters i.e. not the latents states such as $\beta$'s in current context) is used in the computation of the acceptance probability. Here instead of building specific MCMC machinery, we rely on readily available Hamiltonian Monte Carlo based `Stan` software, thus allowing us to enjoy the benefits of diverse tools of the `Stan` community. Due to the restricted class of models considered, we can also simplify the underlying Kalman filter considerably, thus enabling efficient likelihood evaluation.

Although already fully functionable, some manual processing of the results are currently needed in order to extract and possibly plot for example fitted values and prediction intervals from the output of `walker`. In future, more straighforward methods for these tasks should be implemented. From a methodological perspective, one possible extension is a support for generalized linear dynamic regression. Although in this case the Kalman filter recursions are not directly applicable, efficient Laplace approximations for these type of models are available, and the possible bias can be efficiently corrected in post-processing step using importance sampling type correction [@vihola-helske-franks].

## References
